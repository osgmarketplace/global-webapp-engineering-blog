"use strict";(self.webpackChunkglobal_webapp_engineering_blog=self.webpackChunkglobal_webapp_engineering_blog||[]).push([[146],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=u(n),m=o,p=h["".concat(s,".").concat(m)]||h[m]||d[m]||i;return n?a.createElement(p,r(r({ref:t},c),{},{components:n})):a.createElement(p,r({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var u=2;u<i;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1299:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return c},default:function(){return h}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),r=["components"],l={title:"React FAQ",description:"Some basics and helpful information not always shared amongst frontend devs using React",tags:["advanced","frontend","react"],author:"Derek Kershner",author_title:"CTO",author_url:"https://github.com/dkershner6",author_image_url:"https://avatars.githubusercontent.com/u/25798427?v=4"},s="React FAQ",u={permalink:"/global-webapp-engineering-blog/2021/08/16/react-faq",editUrl:"https://github.com/obfns/global-webapp-engineering-blog/tree/main/blog/2021-08-16-react-faq.md",source:"@site/blog/2021-08-16-react-faq.md",title:"React FAQ",description:"Some basics and helpful information not always shared amongst frontend devs using React",date:"2021-08-16T00:00:00.000Z",formattedDate:"August 16, 2021",tags:[{label:"advanced",permalink:"/global-webapp-engineering-blog/tags/advanced"},{label:"frontend",permalink:"/global-webapp-engineering-blog/tags/frontend"},{label:"react",permalink:"/global-webapp-engineering-blog/tags/react"}],readingTime:4.98,truncated:!0,prevItem:{title:"Building Microservices - Book Review",permalink:"/global-webapp-engineering-blog/2021/08/17/building-microservices-book"},nextItem:{title:"Introduction",permalink:"/global-webapp-engineering-blog/2021/08/15/intro"}},c=[{value:"Referential Equality",id:"referential-equality",children:[]},{value:"React Hooks",id:"react-hooks",children:[{value:"Custom React Hooks",id:"custom-react-hooks",children:[]},{value:"React Hook Dependency Arrays",id:"react-hook-dependency-arrays",children:[]},{value:"useMemo / useCallback",id:"usememo--usecallback",children:[]}]}],d={toc:c};function h(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("div",{style:{display:"flex",alignItems:"center",justifyContent:"center",width:"100%",height:"250px",overflow:"hidden"}},(0,i.kt)("img",{src:"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xMS41IC0xMC4yMzE3NCAyMyAyMC40NjM0OCI+CiAgPHRpdGxlPlJlYWN0IExvZ288L3RpdGxlPgogIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSIyLjA1IiBmaWxsPSIjNjFkYWZiIi8+CiAgPGcgc3Ryb2tlPSIjNjFkYWZiIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIi8+CiAgICA8ZWxsaXBzZSByeD0iMTEiIHJ5PSI0LjIiIHRyYW5zZm9ybT0icm90YXRlKDYwKSIvPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIiB0cmFuc2Zvcm09InJvdGF0ZSgxMjApIi8+CiAgPC9nPgo8L3N2Zz4K",width:"50%"})),(0,i.kt)("p",null,"Categorized questions to help with some of the more advanced intracacies of React. When opinions, and not facts, are presented, it is noted."),(0,i.kt)("h2",{id:"referential-equality"},"Referential Equality"),(0,i.kt)("h4",{id:"q-what-is-referential-equality-how-is-it-different-from-other-equalities-and-why-is-it-important-in-react"},"Q. What is referential equality, how is it different from other equalities, and why is it important in React?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Referential equality means the object maintains, as opposed to creates anew, a reference through whatever actions are occurring."),(0,i.kt)("li",{parentName:"ul"},"Strict equality in Javascript, or ===, uses EXACT equality for primitives ('string' === 'string'), or REFERENTIAL equality for objects/arrays (","[1,2,3]"," !== ","[1,2,3]","). React uses this exact same logic to determine if something changed."),(0,i.kt)("li",{parentName:"ul"},'"Something changed" is the most important concept in React (hence the name). When something changes within a component, that component re-renders.',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'The most dangerous situation you can encounter is when something creates a render loop. This is when "something changed" causes another change in an infinite cycle. (see Dependency Array section for defense of this)'))),(0,i.kt)("li",{parentName:"ul"},"React has various tools to control referential equality built in. (See the useMemo / useCallback section for more details)"),(0,i.kt)("li",{parentName:"ul"},'"Render safety", a phrase I made up, is shorthand for "correctly handles referential equality so that all downstream components can rely on the output".')),(0,i.kt)("h2",{id:"react-hooks"},"React Hooks"),(0,i.kt)("h3",{id:"custom-react-hooks"},"Custom React Hooks"),(0,i.kt)("h4",{id:"q-how-should-i-think-about-custom-react-hooks-in-general"},"Q. How should I think about custom React hooks in general?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Hooks are 100% identical to functions aside from one fact: they can also access the native react hooks (useState, useMemo, etc)."),(0,i.kt)("li",{parentName:"ul"},"Because of this, they are also tested differently."),(0,i.kt)("li",{parentName:"ul"},'You should use custom hooks in the exact same way you would use functions that you call inside other functions (naming, easier understanding, encapsulation, reuse, etc). Feel free to nest several, or put a couple in a file with only one "public" one.')),(0,i.kt)("h4",{id:"q-should-i-use-a-custom-hook-or-should-i-build-a-context"},"Q. Should I use a custom hook or should I build a Context?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'This question should be answered identically to "Should I build a context, or should I just do things inside my component?"',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"(Personal Opinion) If you plan on needing these items more than 3 components down (prop drill), use a context."),(0,i.kt)("li",{parentName:"ul"},"If you need these items widely in a horizontal fashion (one component has no common parent to the other), use a context."),(0,i.kt)("li",{parentName:"ul"},"In all other situations, use hook(s)."),(0,i.kt)("li",{parentName:"ul"},"A hook is easier to convert to a Context than vice-versa.")))),(0,i.kt)("h3",{id:"react-hook-dependency-arrays"},"React Hook Dependency Arrays"),(0,i.kt)("h4",{id:"q-why-am-i-forced-to-populate-dependency-arrays-when-fill-in-the-blank-works-as-well-exhaustive-dependencies-eslint-rule"},"Q. Why am I forced to populate dependency arrays when ","[fill in the blank]"," works as well? (Exhaustive Dependencies ESLint Rule)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Kent C. Dodds says it well in ",(0,i.kt)("a",{parentName:"li",href:"https://kentcdodds.com/blog/react-hooks-pitfalls#pitfall-2-not-using-or-ignoring-the-eslint-plugin"},"Pitfall 2"),"."),(0,i.kt)("li",{parentName:"ul"},"Basically, even though something works well right now, doesn't mean it is future-proof. Placing every dependency into the array future-proofs it."),(0,i.kt)("li",{parentName:"ul"},"If you are finding that adding to the array has changed how it works, add conditionals until it runs how it should.")),(0,i.kt)("h4",{id:"q-what-about-a-blank-dependency-array-i-only-want-it-to-run-initially-so-im-good-there-right"},"Q. What about a blank dependency array, I only want it to run initially, so I'm good there, right?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A blank dependency array (when you have actual dependencies, not always the case) shares all the same downsides as a limited dependency array. Works today, maybe not tomorrow."),(0,i.kt)("li",{parentName:"ul"},'The solution is the same, add a conditional. If you have no condition easily available to determine "initial", create one and then change it once you have ran your condition.')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"const [isInitialRender, setIsInitialRender] = useState(true);\n")),(0,i.kt)("h3",{id:"usememo--usecallback"},"useMemo / useCallback"),(0,i.kt)("h4",{id:"q-when-should-i-usememo-and-when-should-i-useeffect--usestate"},"Q. When should I useMemo and when should I useEffect + useState?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"useMemo (or possibly just creating an object) is nearly always the answer. useMemo performs better than useState + useEffect at 1 render per use.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If you are downstream from useQuery, nearly always useMemo. react-query's queryCache is your state."),(0,i.kt)("li",{parentName:"ul"},"If you are downstream from state you control, useMemo."))),(0,i.kt)("li",{parentName:"ul"},"If you are in a situation where you are creating data from a non-api-call, and you are the source of truth, this is a great use case for useEffect + useState. (~1% of the time)")),(0,i.kt)("h4",{id:"q-i-read-an-article-telling-me-not-to-usememo-are-they-right"},"Q. I read an article telling me not to useMemo, are they right?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Generally these fall into a few categories.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The article is actually about React.memo and useMemo got thrown in somehow. React.memo is the FunctionComponent equivalent of PureFunction and should be used sparingly."),(0,i.kt)("li",{parentName:"ul"},"The article is written by someone who is managing an extremely mature, stable React environment, and every performance profiling millisecond counts. If we ever get to this point, I will revise this answer, but it is unlikely. For us, we should value safety to not infinite loop over a few milliseconds.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://kentcdodds.com/blog/usememo-and-usecallback"},"Kent C. Dodds getting into the minutia of exactly when and how"),", for those who are interested in 100% maximization.")))))),(0,i.kt)("h4",{id:"q-do-i-need-to-wrap-fill-in-the-blank-in-a-hook-or-can-i-just-create-a-non-wrapped-same-fill-in-the-blank-usecallback-for-functions-usememo-for-objects"},"Q. Do I need to wrap ","[fill in the blank]"," in a hook, or can I just create a ","[non-wrapped same fill in the blank]","? (useCallback for functions, useMemo for objects)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"These hooks are tools to maintain or break referential equality when you desire. If you do not wrap, a new version (breaking referential equality) is created every render."),(0,i.kt)("li",{parentName:"ul"},"This answer is heavily dependent on where you are in the render tree.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If you are in the child-most component of your domain, you definitely DO NOT need to wrap anything in a hook. There is nothing downstream from you at risk."),(0,i.kt)("li",{parentName:"ul"},"If you are in a global context, you definitely almost always DO need to wrap everything in a hook. There are untold amounts of downstream resources expecting you to handle this well."),(0,i.kt)("li",{parentName:"ul"},"If you are in between, use your discretion, but when it doubt, wrap it."))),(0,i.kt)("li",{parentName:"ul"},"(useMemo specific) This can also depend on what you RETURN from the useMemo. If it is a primitive (string, number, boolean), you DO NOT need to wrap in a useMemo unless the calculation is expensive.")))}h.isMDXComponent=!0}}]);